1.
2.a. 111010110000
the cmp function is comparing the values in the 
2nd and 3rd registers while not being changed, rg 0 and 1 are untouched, and depending on the values in the registers
it will alter the zero flag. If they are the same, then the zero flag is set to 1, 
however, if they are not the same, the zero flag is set to 0, the program counter will then move forward
with the next line in the program.
2.b. 101000110000
the add function is adding the values in the 0 and the 3rd register,
the value in the 0 register will remain unchanged, and the added value will rewrite the value in third register.
The 1 and 2 register will be untouched and the zero flag is dependant on the value of the addition;
if the addition results in a 0 then the zero flag will be set to 1. If its anything else then it will 
be set to 0. After the addition, the program counter will be increased and move to the following line if 
2.c. 001000000001
the jump zero function is soley reliant on the zero flag being set.
If the zero flag is not set, then nothing is going to occur and every register will remain untouched; also the program counter
will not jump anywhere as well. If the zero flag is set then, the program will move to the instruction that is the result 
of the current counter value and a 1 since the imm value is 0001. All the registers are left untouched, and the only special case 
is if this is the instruction at line 15 of the program, it would then wrap around to the beginning as a loop until the jump instruction
gets skipped or ended with a jmp, Rxx, Rxx, 4'b0000 line after it.

3.a. {movi, RXX, Rg1, 4'b0011} 
This will set the value in register 1 to the boolean equivalent of 4'b0011, which is 3, and the program counter will be increased
by one, moving on to the next instruction. All other registers will remain unchanged.
3.b. {add, Rg1, Rg1, 4'b0011}
This instruction will add the value found in register 1 with the boolean equivalent of 4'b0011 which is 3, resulting in the equation Rg1 + 3 = #. 
Rg1 one will retain the result of the sum that occured and its previous value will be replaced. The program counter is increased and the zero flag is also tested,
if the result of this addition is not 0, then the zero flag will not be set; however, if the result is 0, then the zero flag will be set. 
3.c. {jmp, Rxx, Rxx, 4'b0000}
The instruction occuring here will be a jump instruction that is usually found at the end of a program in order to finalize the program counter. 
The registers will remain untouched as well, along with the zero flag, and the program will stop here since it will not increase the 
program counter, unallowing for the continuing through the code.
3.d. {jmp, Rxx, Rxx, 4'b0001}
The instruction here will result in a jump instruction that will move the program counter by the binary equivalent of 4'b0001, resulting in the program counter moving by 1.
The registers will reamin unchanged and the zero flag will also not be touched as well. The only exception is if the program counter is the last line, 15,
the program counter will then encounter an overflow which will result in the program counter being set at 0000, and restarting the code. 

4.a. myROM[3]

4.b. myROM[5]

4.c. myROM[6] 

5.a. 15, the instruction will be run until the comparison instruction before it on myROM[6] turns on the zero flag which then prompts,
the jump zero inttruction to kick in and skip the ROM Cell 8. Since the value in rg 1 is 15, the subtraction instruction will need to be ran until it makes 
the value 0.

5.b. 1, this instruction wil be run whenever the previous function is skipped since the jump zero instruction will jump 3 program instructions,
which ends landing the program counter on my ROM 10 and then continuing to the following jmp instruction, never returning to ROM 10 again.

5.c. 0, same here since the previous instrcution of a jump in myROM[11], will increase the program count by 4, that will result in the program count being at 15 and the instruction
on that line is a 0 jump, signaling the end of the code. 

5.d. 0, the same happends here except for a different reason as the first instruction found in myROM[0] does a jump of 2, meaning that the following instruction after 
is the one found in myROM [2]. As a result, the instruction in myROM [1] will never be touched since the code never returns to myROM [1]. 

5.e. The program is counting down from 15 to 0 and whenever it reaches that point, another value in a different register is decreased from 15 to 14, signaling the end of the program. 
The assembly code is acting a loop, meaning that it can be ran without manually having to write out a subtract instruction multiple times, and instead only written once. The way the loop works
is by comparison, as it will continue running until the value found in the register that is being looped on reaches 0. Once that occurs, the program skips over the comparion opeartion and moves on to subtract 
a value from the second register present and finalizing the code. 



